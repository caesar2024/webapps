<!DOCTYPE html>
<html>

<head>
    <script src="plotly-2.20.0.min.js" charset="utf-8"></script>
    <script src="math.js" charset="utf-8"></script>
    <script src="module.js" charset="utf-8"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="stylesheet.css">
</head>

<body>
    <table style="width:100%">
        <tr>
            <th>
                <p>N<sub>t</sub> = <span id="NValue"></span> cm<sup>3</sup></p>
            </th>
            <th>
                <p>LWC = <span id="muValue"></span> g m<sup>-3</sup></p>
            </th>
            <th>
                <p>CV = σ/μ = <span id="sigmaValue"></span></p>
            </th>
        </tr>
        <tr>
            <td>
                <div class="slidecontainer">
                    <input type="range" min="10" max="200" step="10" value="100" class="slider" id="N">
                </div>
            </td>
            <td>
                <div class="slidecontainer">
                    <input type="range" min="0" max="1" step="0.1" value="0.6" class="slider" id="mu">
                </div>
            </td>
            <td>
                <div class="slidecontainer">
                    <input type="range" min="0.07" max="0.3" step="0.01" value="0.15" class="slider" id="sigma">
                </div>
            </td>
        </tr>
    </table>

    <p>Mean droplet diameter =  <span id="theValue"></span> μm </p>

    <div id="plot1"></div>
    <div id="plot2"></div>
    <div id="plot3"></div>
    <script>
        var Nslider = document.getElementById("N");
        var Noutput = document.getElementById("NValue");
        var sigmaslider = document.getElementById("sigma");
        var sigmaoutput = document.getElementById("sigmaValue");
        var muslider = document.getElementById("mu");
        var muoutput = document.getElementById("muValue");
        var the = document.getElementById("theValue");
        sigmaoutput.innerHTML = sigmaslider.value;
        muoutput.innerHTML = muslider.value;
        Noutput.innerHTML = Nslider.value;
    
        
        function ndsolve(f, x0, dt, tmax) {
            let x = x0.clone()  // Current values of variables
            const result = [x]  // Contains entire solution
            const nsteps = math.divide(tmax, dt)   // Number of time steps
            for (let i = 0; i < nsteps; i++) {
                const dxdt = f.map(func => func(...x.toArray()))
                const dx = math.multiply(dxdt, dt)
                x = math.add(x, dx)
                result.push(x)
            }
            return math.matrix(result)
        }

        math.import({ ndsolve })

        const sim = math.parser()

        function plotme(n) {
            const CV  = sigmaslider.value
            const ν = 0.112 / Math.pow(CV,2.0) - 1.0
            // const mDg = muslider.value
            const Lc = muslider.value * 1e-6
            console.log(Lc)
            var Dg = Math.pow(muslider.value * 1e-6 * 6/Math.PI/1e6/Nslider.value, 1/3) * 1e6  
            the.innerHTML = Dg.toFixed(1)  

            evalstr = "nu = " + ν.toString()
            sim.evaluate(evalstr)
            sim.evaluate("xstar = 2.6e-7") 
            sim.evaluate("kc = 9.44e9") 
            sim.evaluate("kr = 5.78e3") 

            sim.evaluate("xc(Lc, Nc) = Lc/Nc") 
            sim.evaluate("tau(Lc, Lr) = 1 - Lc/(Lc + Lr)") 
            sim.evaluate("phi_au(tau) = 600*tau^0.68*(1-tau^0.68)^3") 
            sim.evaluate("phi_ac(tau) = (tau/(tau + 5e-4))^4") 
            
            sim.evaluate("dLrdtau(Lr, Lc, Nr, Nc, t) = kc/(20 * xstar) * (nu+2)*(nu+4)/(nu+1)^2*Lc^2*xc(Lc, Nc)^2") //*(1+phi_au(tau(Lc,Lr))/(1-tau(Lc,Lr))^2)") 
            sim.evaluate("dLrdtac(Lr, Lc, Nr, Nc, t) = kr * Lc * Lr * phi_ac(tau(Lc, Lr))") 
            
            sim.evaluate("dLcdtau(Lr, Lc, Nr, Nc, t) = -dLrdtau(Lr, Lc, Nr, Nc, t)") 
            sim.evaluate("dLcdtac(Lr, Lc, Nr, Nc, t) = -dLrdtac(Lr, Lc, Nr, Nc, t)") 

            sim.evaluate("dNcdtau(Lr, Lc, Nr, Nc, t) = 2/xstar*dLcdtau(Lr, Lc, Nr, Nc, t)") 
            sim.evaluate("dNcdtac(Lr, Lc, Nr, Nc, t) = 1/xc(Lc, Nc)*dLcdtac(Lr, Lc, Nr, Nc, t)") 

            sim.evaluate("dNrdtau(Lr, Lc, Nr, Nc, t) = -1/2*dNcdtau(Lr, Lc, Nr, Nc, t)") 
            sim.evaluate("dNrdtac(Lr, Lc, Nr, Nc, t) = -kr*Nr*Lr") 

            sim.evaluate("dNcdtsc(Lr, Lc, Nr, Nc, t) = -kc*(nu+2)/(nu+1)*Lc^2 - dNcdtau(Lr, Lc, Nr, Nc, t)") 

            sim.evaluate("dLcdt(Lr, Lc, Nr, Nc, t) = dLcdtau(f(Lr), f(Lc), f(Nr), f(Nc), t) + dLcdtac(f(Lr), f(Lc), f(Nr), f(Nc), t)") 
            sim.evaluate("dLrdt(Lr, Lc, Nr, Nc, t) = dLrdtau(f(Lr), f(Lc), f(Nr), f(Nc), t) + dLrdtac(f(Lr), f(Lc), f(Nr), f(Nc), t)") 
            sim.evaluate("dNcdt(Lr, Lc, Nr, Nc, t) = dNcdtau(f(Lr), f(Lc), f(Nr), f(Nc), t) + dNcdtac(f(Lr), f(Lc), f(Nr), f(Nc), t) + dNcdtsc(f(Lr), f(Lc), f(Nr), f(Nc), t)") 
            sim.evaluate("dNrdt(Lr, Lc, Nr, Nc, t) = dNrdtau(f(Lr), f(Lc), f(Nr), f(Nc), t) + dNrdtac(f(Lr), f(Lc), f(Nr), f(Nc), t)") 
            sim.evaluate("dtdt(Lr, Lc, Nr, Nc, t) = 1")

            sim.evaluate("dt = 100")
            sim.evaluate("tfinal = 18000")
            sim.set('f', function (x) {
                if (x < 0) {
                    return x
                }
                return x
            })
            Nstr = Nslider.value.toString()
            Lcstr = Lc.toString()

            initial = "[0, " + Lcstr + ", 0, " + Nstr + ", 0]"
            console.log(initial)
            console.log("result = ndsolve([dLrdt, dLcdt, dNrdt, dNcdt, dtdt]," +  initial + ", dt, tfinal)")
            sim.evaluate("result = ndsolve([dLrdt, dLcdt, dNrdt, dNcdt, dtdt]," +  initial + ", dt, tfinal)")

            const out = sim.evaluate("result[:,[1,2,3,4,5]]").toArray().map(([Lr, Lc, Nr, Nc, t]) => ({ Lr, Lc, Nr, Nc, t }))
            var trace1 = {
                x: out.map(f => f.t/60/60),
                y: out.map(f => f.Lc*1e6),
                mode: 'lines',
                type: 'line',
                name: 'Cloud',
                line: {
                    color: 'rgb(0,0,0)',
                    width: 2
                }
            };

            var trace2 = {
                x: out.map(f => f.t/60/60),
                y: out.map(f => f.Lr*1e6),
                mode: 'lines',
                type: 'line',
                name: 'Rain',
                line: {
                    color: 'rgb(0.31,0.58,0.8)',
                    width: 2
                }
            };

            var data = [trace1, trace2];

            var layout1 = {
                title: "",
                showlegend: true,
                // font: { size: 12 }
                xaxis: {
                    minor: { showgrid: true },
                    range: [0, 5]
                },
                yaxis: {
                    title: "LWC (g m⁻³)",
                    range: [0, 1],
                    minor: { showgrid: true },

                },
                margin: {
                    l: 50,
                    r: 50,
                    b: 8,
                    t: 20,
                    pad: 4
                },
                height: 130,
            };

            var config = {
                responsive: true,
                scrollZoom: true,
                staticPlot: false,
                displayModeBar: false
            }

            
            var trace1a = {
                x: out.map(f => f.t/60/60),
                y: out.map(f => f.Lc/f.Nc),
                mode: 'lines',
                type: 'line',
                name: 'Cloud',
                line: {
                    color: 'rgb(0,0,0)',
                    width: 2
                }
            };

            var trace2a = {
                x: out.map(f => f.t/60/60),
                y: out.map(f => Math.pow(f.Lr * 6/Math.PI/1e6/f.Nr, 1/3) * 1e6),
                mode: 'lines',
                type: 'line',
                name: 'Rain',
                line: {
                    color: 'rgb(0.31,0.58,0.8)',
                    width: 2
                }
            };

            var trace1a = {
                x: out.map(f => f.t/60/60),
                y: out.map(f => Math.pow(f.Lc * 6/Math.PI/1e6/Nslider.value, 1/3) * 1e6),
                mode: 'lines',
                type: 'line',
                name: 'Cloud',
                line: {
                    color: 'rgb(0,0,0)',
                    width: 2
                }
            };

            var layout2 = {
                title: "",
                showlegend: true,
                // font: { size: 12 }
                xaxis: {
                    minor: { showgrid: true },
                    // title: "Time (min)",
                    // type: 'log',
                    range: [0, 5]
                },
                yaxis: {
                    title: "D (μm)",
                    range: [0, 1100],
                    minor: { showgrid: true }
                },
                margin: {
                    l: 50,
                    r: 98,
                    b: 8,
                    t: 4,
                    pad: 4
                },
                height: 120,
            };


            var trace2b = {
                x: out.map(f => f.t/60/60),
                y: out.map(f => f.Nr * 1000),
                mode: 'lines',
                type: 'line',
                name: 'Rain',
                line: {
                    color: 'rgb(0.31,0.58,0.8)',
                    width: 2
                }
            };

            var layout3 = {
                title: "",
                showlegend: true,
                // font: { size: 12 }
                xaxis: {
                    title: "Time (hr)",
                    type: 'lin',
                    minor: { showgrid: true },
                    range: [0, 5]
                    // range: [0, 50]
                },
                yaxis: {
                    title: "N (L⁻¹)",
                    minor: { showgrid: true },
                    // range: [0, 30]
                },
                margin: {
                    l: 50,
                    r: 98,
                    b: 40,
                    t: 0,
                    pad: 4
                },
                height: 150,
            };

            var config = {
                responsive: true,
                scrollZoom: true,
                staticPlot: false,
                displayModeBar: false
            }

            var config = {
                responsive: true,
                scrollZoom: true,
                staticPlot: false,
                displayModeBar: false
            }

            sigmaoutput.innerHTML = sigmaslider.value;
            muoutput.innerHTML = muslider.value;
            Noutput.innerHTML = Nslider.value;

            Plotly.newPlot(plot1, data, layout1, config);
            Plotly.newPlot(plot2, [trace2a], layout2, config);
            Plotly.newPlot(plot3, [trace2b], layout3, config);
            return 0; 
        }

        function sigma_callback() {
            console.log(plotme(Number(sigmaslider.value)));
        }
        sigmaslider.oninput = sigma_callback;

        function N_callback() {
            console.log(plotme(Number(Nslider.value)));
        }
        Nslider.oninput = N_callback;

        function mu_callback() {
            console.log(plotme(Number(muslider.value)));
        }
        muslider.oninput = mu_callback;

        plotme(Number(sigmaslider.value));
    </script>

</body>

</html>
